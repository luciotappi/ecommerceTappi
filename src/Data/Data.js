export const Categories =[

  {
    "categoryName":"Microcontroladores",
    "categoryId":0
  },

  {
    "categoryName":"Placas",
    "categoryId":1
  },
  
  {
    "categoryName":"Sensores",
    "categoryId":2
  }
 

]

export const Data =[
    {
        "id": 0,  
        "title": "Arduino Uno",
          "description": "Placa de desarrollo Arduino Uno basada en ATMega328P. Chip CH340 + Cable de programacion",
          "descriptionLarge": "Microcontrolador: ATmega328.Tension de Operacion (nivel logico): 5 V. Tension de Alimentacion (pin Vin): 7-12 V. Pines E/S Digitales: 14 (de los cuales 6 proveen de salida PWM). Entradas Analogicas: 6 (pueden usarse como digitales). Corriente max por cada PIN de E/S: 40 mA. Memoria Flash: 32 KB de los cuales 0.5KB son usados por el bootloader. SRAM: 2 KB. EEPROM: 1 KB. Frecuencia de reloj:16 MHz",
          "price":"$4000",
          "info":"https://arduino.cl/arduino-uno/", 
          "image":"../images/arduino-uno.png",
          "stock": 5,
          "categoryName":"Microncontroladores",
          "categoryId":0,
          "initial":3
          
          
        },

        {
          "id": 4,  
          "title": "Arduino Uno 2",
            "description": "Placa de desarrollo Arduino Uno basada en ATMega328P. Chip CH340 + Cable de programacion",
            "descriptionLarge": "Microcontrolador: ATmega328.Tension de Operacion (nivel logico): 5 V. Tension de Alimentacion (pin Vin): 7-12 V. Pines E/S Digitales: 14 (de los cuales 6 proveen de salida PWM). Entradas Analogicas: 6 (pueden usarse como digitales). Corriente max por cada PIN de E/S: 40 mA. Memoria Flash: 32 KB de los cuales 0.5KB son usados por el bootloader. SRAM: 2 KB. EEPROM: 1 KB. Frecuencia de reloj:16 MHz",
            "price":"$4000",
            "info":"https://arduino.cl/arduino-uno/", 
            "image":"../images/arduino-uno.png",
            "stock": 5,
            "categoryName":"Placas",
            "categoryId":1,
            "initial":3
            
            
          },
        
        {
          "id": 1,
          "title": "ESP32",
          "description": "Placa de desarollo ESP32 con procesador Tensilica Xtensa 32-bit LX6, antena Wi-Fi y receptor Bluetooth integrado",
          "descriptionLarge": "Microcontrolador: ATmega328.Tension de Operacion (nivel logico): 5 V. Tension de Alimentacion (pin Vin): 7-12 V. Pines E/S Digitales: 14 (de los cuales 6 proveen de salida PWM). Entradas Analogicas: 6 (pueden usarse como digitales). Corriente max por cada PIN de E/S: 40 mA. Memoria Flash: 32 KB de los cuales 0.5KB son usados por el bootloader. SRAM: 2 KB. EEPROM: 1 KB. Frecuencia de reloj:16 MHz",
          "price":"$3000",
          "info":"http://esp32.net/",
          "image":"../images/esp32.png",
          "stock":32,
          "categoryName":"Placas",
          "categoryId":1,
          "initial":1
          
          
        },

        {
          "id": 5,
          "title": "ESP32 2",
          "description": "Placa de desarollo ESP32 con procesador Tensilica Xtensa 32-bit LX6, antena Wi-Fi y receptor Bluetooth integrado",
          "descriptionLarge": "Microcontrolador: ATmega328.Tension de Operacion (nivel logico): 5 V. Tension de Alimentacion (pin Vin): 7-12 V. Pines E/S Digitales: 14 (de los cuales 6 proveen de salida PWM). Entradas Analogicas: 6 (pueden usarse como digitales). Corriente max por cada PIN de E/S: 40 mA. Memoria Flash: 32 KB de los cuales 0.5KB son usados por el bootloader. SRAM: 2 KB. EEPROM: 1 KB. Frecuencia de reloj:16 MHz",
          "price":"$3000",
          "info":"http://esp32.net/",
          "image":"../images/esp32.png",
          "stock":32,
          "categoryName":"Placas",
          "categoryId":1,
          "initial":1
          
          
        },
      
        {
          "id": 2,  
          "title": "STM32",
          "description": "Placa de desarrollo STM32 Blue pill basada en STM32F103C8T6 STM32 Blue Pill CPU ARM 32 Cortex-M3",
          "descriptionLarge": "Microcontrolador: ATmega328.Tension de Operacion (nivel logico): 5 V. Tension de Alimentacion (pin Vin): 7-12 V. Pines E/S Digitales: 14 (de los cuales 6 proveen de salida PWM). Entradas Analogicas: 6 (pueden usarse como digitales). Corriente max por cada PIN de E/S: 40 mA. Memoria Flash: 32 KB de los cuales 0.5KB son usados por el bootloader. SRAM: 2 KB. EEPROM: 1 KB. Frecuencia de reloj:16 MHz",
          "price":"$2500",
          "info":"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",
          "image":"../images/stm32.png",
          "stock":0,
          "categoryName":"Placas",
          "categoryId":1,
          "initial":1
          
        },
        
        {
          "id": 6,  
          "title": "STM32 2",
          "description": "Placa de desarrollo STM32 Blue pill basada en STM32F103C8T6 STM32 Blue Pill CPU ARM 32 Cortex-M3",
          "descriptionLarge": "Microcontrolador: ATmega328.Tension de Operacion (nivel logico): 5 V. Tension de Alimentacion (pin Vin): 7-12 V. Pines E/S Digitales: 14 (de los cuales 6 proveen de salida PWM). Entradas Analogicas: 6 (pueden usarse como digitales). Corriente max por cada PIN de E/S: 40 mA. Memoria Flash: 32 KB de los cuales 0.5KB son usados por el bootloader. SRAM: 2 KB. EEPROM: 1 KB. Frecuencia de reloj:16 MHz",
          "price":"$2500",
          "info":"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",
          "image":"../images/stm32.png",
          "stock":0,
          "categoryName":"Placas",
          "categoryId":1,
          "initial":1
          
        },
        
        {
          "id": 7,  
          "title": "Sensor De Movimiento Hc-sr501 ",
          "description": "El sensor PIR detecta el movimiento de personas hasta 7 metros de distancia",
          "descriptionLarge": "El sensor PIR detecta el movimiento de personas hasta 7 metros de distancia mediante el uso de una lente de Fresnel y el elemento sensible al infrarrojo para detectar cambios en los patrones de radiacion infrarroja emitida por los objetos en su vecindad. Barato y fácil de usar, es ideal para sistemas de alarma, la iluminación activada por movimiento, y accesorios de fiesta.Rango de Trabajo : DC 4.5V- 20V.Consumo :<60uA. Voltage de Salida : High/Low nivel de señal :3.3V TTL output.- Temperatura de Trabajo : -20/+80°C.- Dimensiones : 3.2cm x 2.4cm x 1.8cm",
          "price":"$390",
          "info":"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",
          "image":"../images/hc-sr501.png",
          "stock":2,
          "categoryName":"Sensores",
          "categoryId":2,
          "initial":1
          
        } 

        ,
        
        {
          "id": 8,  
          "title": "Reed Switch 2x14mm Normal Abierto 1a 100v sensor Magnetico ",
          "description": "Contacto Normalmente Abierto.10 W/VA Máximo.100 Vac/dc Máximo. 0.5 A Máximo.Medidas: 14 x 2 mm.  Modelo: GC 2325",
          "descriptionLarge": "Contacto Normalmente Abierto.10 W/VA Máximo.100 Vac/dc Máximo. 0.5 A Máximo.Medidas: 14 x 2 mm.  Modelo: GC 2325.Están herméticamente sellados en un ambiente de vidrio, libres de contaminación y son seguros para su uso en entornos industriales y explosivos difíciles. Los Interruptores Reed son inmunes a las descargas electrostáticas ( ESD ) y no requieren ningún circuito externo de protección contra ESD. La resistencia de aislamiento entre los contactos es tan alta como 10 15 ohmios, y la resistencia de contacto es tan baja como 50 mili-ohmios. Los interruptores Reed pueden cambiar directamente cargas de tan pocos microvatios sin necesidad de circuitos de amplificación externos.",
          "price":"$242",
          "info":"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",
          "image":"../images/reedsw-GC 2325.png",
          "stock":4,
          "categoryName":"Sensores",
          "categoryId":2,
          "initial":1
          
        } ,
        
        {
          "id": 9,  
          "title": "Sensor Ultrasónico Hc-sr04 Para Arduino Pic Robotica",
          "description": "",
          "descriptionLarge": "El sensor HC-SR04 es una excelente opción como sensor de distancia ultrasónico. Su relación de costo/beneficio lo hace óptimo para un gran abanico de aplicaciones. El uso de este módulo es bastante sencillo debido a que se toda la electrónica de control, transmisión y recepción se encuentra contenida en PCB. El usuario solamente debe enviar un pulso de disparo y medir en tiempo alto del pulso de respuesta. Solamente se requieren 4 hilos para completar la interfaz con el módulo de sensor HC-SR04.El HC-SR04 es compatible con la mayoría de los microcontroladores del mercado, incluyendo el Arduino UNO, Arduino MEGA y otras tarjetas compatibles que funcionen con 5 volts. Existen librerías para este módulo que hacen que la parte del software quede resuelta de manera muy sencilla. Recomendamos adquirir algunos cables tipo Dupont para poder usar este sensor sin necesidad de realizar soldaduras.",
          "price":"$553",
          "info":"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",
          "image":"../images/usonico-Hc-sr04.png",
          "stock":80,
          "categoryName":"Sensores",
          "categoryId":2,
          "initial":1
          
        }  ,
        
        {
          "id": 10,  
          "title": "Sensor Humedad Relativa Temperatura Dht22 Arduino",
          "description": "El sensor DHT22 supone una mejora considerable en las características técnicas con respecto al DHT11 a cambio de un pequeño incremento en el precio.Cuando lo que buscamos es cierta precisión en nuestras mediciones, lo más seguro es que el sensor DHT11 nos haya dejado un poco fríos, principalmente por el amplio error en la medición y el escaso rango de temperatura.",
          "descriptionLarge": "El DHT22 es un sensor digital de temperatura y humedad relativa de buen rendimiento y bajo costo. Utiliza un sensor capacitivo de humedad y un termistor para medir el aire circundante, y muestra los datos mediante una señal digital en el pin de datos. Es bastante simple de usar, pero requiere sincronización cuidadosa para tomar datos. El único inconveniente de este sensor es que sólo se puede obtener nuevos datos una vez cada 2 segundos, así que las lecturas que se pueden realizar serán mínimo cada 2 segundos.Sólo tienes que conectar el primer pin de la izquierda a la fuente de alimentación 3-5V, el segundo pin a tu pin de entrada de datos y el cuarto (último) pin a tierra. A pesar de que utiliza un solo cable para enviar datos no es compatible con el protocolo de Dallas One-Wire, sin embargo el protocolo es sencillo de implementar. Si desea conectar varios sensores, cada uno debe tener su propio pin de datos. Hay una librería de ejemplo disponible para Arduino.El DHT22 presenta mejores prestaciones respecto al sensor DHT11.",
          "price":"$1359",
          "info":"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",
          "image":"../images/dht22.png",
          "stock":715,
          "categoryName":"Sensores",
          "categoryId":2,
          "initial":1
          
        }  ,
        
        {
          "id": 11,  
          "title": "Modulo Sensor Aht10 Temperatura Precision Humedad Arduino",
          "description": "MODULO SENSOR TEMPERATURA HUMEDAD ARDUINO COMPATIBLE AHT10 ALTA PRECISION DIGITAL I2C",
          "descriptionLarge": "El AHT10, una nueva generación de sensores de temperatura y humedad, establece un nuevo estandar en tamano e inteligencia: esta integrado en un paquete SMD sin plomo plano de doble fila para soldadura por reflujo con 4x5mm inferior y una altura de 1,6mm. El sensor emite una senal digital calibrada en formato I 2C estandar. El AHT10 esta equipado con un chip ASIC nuevo disenado, un elemento de detección de humedad capacitivo MEMS semiconductor mejorado y un elemento de detección de temperatura estandar en chip. Su rendimiento ha mejorado mucho mas alla del nivel de fiabilidad de los sensores de generación anterior. Se ha mejorado la primera generación de sensores de temperatura y humedad para que sean mas estables en entornos duros.",
          "price":"$1359",
          "info":"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",
          "image":"../images/aht10.png",
          "stock":0,
          "categoryName":"Sensores",
          "categoryId":2,
          "initial":1
          
        }  ,
        
        {
          "id": 12,  
          "title": "Sensor De Humedad En Suelo - Capacitivo Analogico",
          "description": "Este sensor capacitivo análogo de la humedad del suelo mide niveles de la humedad del suelo por la detección capacitiva.Está hecho de un material resistente a la corrosión que le da una larga vida útil. Insertarlo en el suelo e impresionar a tus amigos con los datos de humedad del suelo en tiempo real.",
          "descriptionLarge": "Este sensor de humedad del suelo capacitivo se distingue de la mayoría de los sensores resistivos del mercado y utiliza sensor capacitivo para detectar la humedad del suelo. El problema de que el sensor de resistencia se corroe fácilmente se evita, y su vida útil se extiende considerablemente.El sensor tiene un chip regulador de voltaje integrado que soporta un entorno de trabajo de 5 V, lo que significa que funciona incluso en una placa de control de 5 V Arduino. Un PC en miniatura como el Raspberry Pi' sólo necesita un módulo de conversión ADC externo (analógico a digital de señal) para funcionar.Con una pantalla externa y una placa base, de cierta manera puedes hablar con tus plantas. Ver si es sed o si no necesitan más agua para hidratar.",
          "price":"$542",
          "info":"https://www.st.com/en/microcontrollers-microprocessors/stm32-32-bit-arm-cortex-mcus.html",
          "image":"../images/sensorcapacitivohumedad.png",
          "stock":5,
          "categoryName":"Sensores",
          "categoryId":2,
          "initial":1
          
        } 
        
        
      ]
  
      export const searchCategories = () => 
          {
            return new Promise((res,rej)=>
            {
              let condition = true
              if (condition)
              {
                setTimeout(()=>
                {
                  console.log(Categories);
                  res(Categories);
                  // rej(console.log("ERROR EN BASE DE DATOS"))
                },2000)
              } else
              {
                rej(console.log("No hay datos"))
              }
            })
          } 

      // export const getItem= (Item) => {
      // // const getItem = function (Item){

      //   return new Promise((res,rej)=>
      //   {

      //     let condition = true
      //     if (condition){
      //       setTimeout(()=>{
      //       if (Item != null)  
      //       {
      //         console.log("EL RESLTADO DE LA BUSQUEDA ES : ")
      //         console.log(Data[Item]);
      //         res(Data[Item])

      //       }else
      //       {
      //         res(Data)

      //       }
      //         },2000);
      //       }
      //       else{

      //           rej(console.log("No hay datos"))
      //       }
      //     })
      //     }
      

          export const getItemByCategory= (categoryId) => {
            // const getItem = function (Item){
      
              return new Promise((res,rej)=>
              {
      
                let condition = true
                if (condition)
                {

                  // SI NO SE PASA LA CATEGORIA, DEVUELVO TODOS LOS PRODUCTOS ( COMO ES EL CASO DE CUANDO VOY A HOME)
                 
                    setTimeout(()=>
                    {
                      if (categoryId != null) 
                      {
                      res(Data.filter(prod=>prod.categoryId == categoryId))
                      // rej(console.log("ERROR EN BASE DE DATOS"))
                    } else
                    {
                      res(Data)
                    }
                    },2000)
                  
                }
              })
            }

            export const getItem= (itemId) => {
              // const getItem = function (Item){
        
                return new Promise((res,rej)=>
                {
        
                  let condition = true
                  if (condition){
                    setTimeout(()=>{
                      const resultado =Data.filter(product=>product.id == itemId);
                      console.log("EL RESLTADO DE LA BUSQUEDA ES : ")
                      console.log(resultado[0]);
                      res(resultado[0]);
                      // rej(console.log("ERROR EN BASE DE DATOS"))
                  },2000)
                  }
                })
              }
      
  
      // export default getFetch;
      //  export default getItem;